"""Test Suite for Lykaner5 Current Consumption Regression"""

from datetime import datetime
import pandas as pd
import numpy as np
import os

from NSTAX.testscripts.test_script import TestScript
from NSTAX.testscripts.lykaner5_current_detect import ActivationAnalysis

class CurrentBaseScript(TestScript):
    """Base test script for Current Consumption Suite.
       Includes common methods and variables.
    """
    def __init__(self):
        super().__init__()
        # self.c_data = self._load_latest_file()
        
    def _load_latest_file(self, directory="../current_logs"):
        """Loads the latest current log generated by the PPK2 api from the set folder.

        :param directory: location of the current files., defaults to "../current_logs"
        :type directory: str, optional
        :return: array of time and current data
        :rtype: numpy.array
        """
        csv_files = [file for file in os.listdir(directory) if file.endswith(".csv")]
        # timestamps = [file.split("_")[1] for file in csv_files]
        timestamps = [file.split("_")[2] + "_" + file.split("_")[3].split(".")[0] for file in csv_files]
        timestamps = [datetime.strptime(ts, "%Y%m%d_%H%M%S") for ts in timestamps]
        latest_index = timestamps.index(max(timestamps))
        latest_csv_file = csv_files[latest_index]
        
        file_path = os.path.join(directory, latest_csv_file)

        df = pd.read_csv(file_path, header=None, names=['Time', 'Current'])
        df['Time'] = pd.to_datetime(df['Time'], format='%d-%m-%Y_%H:%M:%S.%f')
        df['Time'] = (df['Time'] - df['Time'].min()).dt.total_seconds()

        current_column = np.array(df['Current'].values)
        time_column = np.array(df['Time'].values)
        np_data = np.column_stack((time_column, current_column))

        # print(np_data)
        
        # Output np_data to a new CSV file
        np.savetxt('output_data.csv', np_data, delimiter=',', header='Time,Current', comments='')
        
        return np_data
    
    def _load_test_file(self):
        """Read the specified test file (For DEBUG use only)
        """
        self.data = pd.read_csv('ppk_test_act_trim.csv')
        
class CurrentConsumption_Regression(CurrentBaseScript):
    """Perform Current Regression on a single tracker.

    Purpose of this test is to check if current values of the different device features
    are within the expected range, compared to a reference tracker.

    Pre-conditions:
        - An un-activated Lykaner 5tracker flashed with regular Activation sequence (default params)
        - Pre-generated reference graphs (current) for comparison
    """
    def __init__(self):
        super().__init__()
        self.name = "CurrentConsumption_Regression"
        self.automation_content = "CurrentConsumption_Regression"
        self.version = 0.1
        self.requirement["DUT"].append("Sigfox")
        self.n_steps = 3
        
        self.result_output = {}
        
    def get_expected_activation_output(self, states):
        exp_out = np.array([])
        for state in states:
            if state == "LED_5":
                exp_out = np.append(exp_out, 1)
            if state == "LED_10":
                exp_out = np.append(exp_out, 1)
            if state == "UL_ACT":
                exp_out = np.append(exp_out, 3)
            if state == "UL_DLRQ":
                exp_out = np.append(exp_out, 1)
            if state == "UL_MAC":
                exp_out = np.append(exp_out, 1)
            if state == "WIFI_SCAN":
                exp_out = np.append(exp_out, 1)
        print(exp_out)
        return exp_out
        
    def teststeps(self):
        """ Description of steps:
            1. Measure the current (using PPK2 API)
            2. Run current state classifiers (eg. LED_5, LED_10, UL_DLRQ)
            ...
            3. Validate number of states (against expected number)
            4. Result output
        """
        # Get variables from config
        test_parameters = self.params_from_testcfg
        test_file = test_parameters.get('current_file')
        measure_period = test_parameters.get('measure_period')
        current_states = test_parameters.get('current_states')
        self.file_index = test_parameters.get('file_index')
        self.activation_output = self.get_expected_activation_output(current_states)
        
        # Update test details
        self.name = "CurrentConsumption_Regression_" + str(self.file_index)
        self.n_steps = 2 + len(current_states)
        
        # Step 1: Measure device activation cycle
        step_description = f"Measure cycle time: {measure_period}s"
        expected_result = "Activation Complete"
        actual_result = ""
        self.logger.info("Step 1: %s", step_description)
        measure_status = self.DUT.measure_current(measure_period)
        # t1 = self._get_current_ts_utc()
        if measure_status:
            # Activation successful
            actual_result = "Activation Complete"
            step_verdict = self.result_classifier.PASSED
        else:
            # Issue with Activation
            actual_result = "Error in Activation. Check Graph"
            step_verdict = self.result_classifier.FAILED
            self.logger.error("Step failed, skipping remaining steps")
        self.save_step(1, step_description, expected_result, actual_result, step_verdict)
        
        for step_number, current_state in enumerate(current_states, start=2):
            # Step N: Measure state: Run classifier
            step_description = f"Run classifier type: {current_state}"
            expected_result = "State Detection Complete"
            actual_result = ""
            self.logger.info("Step %d: %s", step_number, step_description)
            
            # Run the classifier for the current state
            measure_status = self.DUT.detect_current_state(current_state, test_file)
            
            if measure_status:
                actual_result = "State Detection Complete"
                step_verdict = self.result_classifier.PASSED
            else:
                actual_result = "Error in State Detection."
                step_verdict = self.result_classifier.FAILED
                # self.logger.error("Step failed, skipping remaining steps")
            
            # Save the step result
            self.save_step(step_number, step_description, expected_result, actual_result, step_verdict)

        # Step Final: Check labeled/detected states
        step_description = f"Check no. of labeled/detected states: {self.activation_output}"
        expected_result = "All states present"
        actual_result = ""
        self.logger.info(f"Step {self.n_steps}: %s", step_description)
        # t2 = self._get_current_ts_utc()
        
        # Get all detected states from previous step
        output = self.DUT.get_detected_states()
        output = ActivationAnalysis.filter_output(output)
        
        validation_status = self._validate_states(output)

        if validation_status:
            actual_result = "State Validation Complete"
            step_verdict = self.result_classifier.PASSED
        else:
            actual_result = "Error in State Validation. Check Graph"
            step_verdict = self.result_classifier.FAILED
        # Save the step result
        self.save_step(self.n_steps, step_description, expected_result, actual_result, step_verdict)
            
        # Show Result Output (State table and graph)
        print(output)
        self._save_table(output)
        self._save_graph(output, test_file)
        
    def _validate_states(self, output_states):
        """Compare all detected states to expected amount

        :param output_states: table of all the detected states
        :type output_states: pandas.DataFrame()
        :return: result, if expected matches actual output number of states
        :rtype: bool
        """
        try:
            state_counts  = output_states.groupby('State_Name').size().values
        except KeyError as ke:
            print(f"Column not found, {ke}. Dataframe is likely empty.")
            state_counts = 0
            
        print(state_counts)
        
        result = np.array_equal(state_counts, self.activation_output)
        print(result)

        return result
                
    def _save_table(self, output):
        """Save the generated state table as an html output for result engine

        :param output: table of all the detected states
        :type output: pandas.DataFrame()
        """
        try:
            html_table = output[["State_Name", "Time_Delta(s)", "Expected_Current(mA)", "Average_Current(mA)", "Status"]].to_html(index=False ,classes='result-table')        
            self.result_output["table"] = f'''{html_table}'''
        except KeyError as ke:
            print(f"Empty table. Error: {ke}")
        
    def _save_graph(self, output, file):
        """Save the dectected states overlayed on the raw current graph for result engine

        :param output: table of all the detected states
        :type output: pandas.DataFrame()
        :param file: the raw current file to use for plotting (set in test_config)
        :type file: str
        """
        # Extract the folder name
        folder_name = "results/" + os.path.basename(self.log_folder)
        current_graph = self.DUT.plot_current_graph(output,self.file_index, folder_name, file)
        self.result_output["image"] = f'''<img src="output_figure_{self.file_index}.png">'''

    def get_result_output(self):
        """Returns the state table and graph for higher level methods"""
        return self.result_output
        
        
if __name__ == "__main__":
    test = CurrentBaseScript()